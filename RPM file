import RP.GPIO as GPIO
import time

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(false)

pulse = 0
distance = 0
rpm = 0
speed = 0
r = 0.12
wheel_c = 2*pi*r
multiplier = 0
hall = 18
elapse = 0

start = time.time()

GPIO.setup(hall,GPIO.IN,pull_up_down=GPIO.PUD.UP)

def get_rpm():
	return rpm
def get_distance():
	return speed
def get_distance():
	return distance
def get_elapse():
	return elapse
def get_multiplier():
	return multiplier
	
	
def handle_falling_edge():
	start = time.time()
	distance += wheel_c

def handle_rising_edge():
	pass 
	

def get_pulse(number):
	global elapse,distance,start,pulse,speed,rpm,multiplier
	
	elapse = time.time() - start
	
	if GPIO.event_detected(hall):
		print("FALLING EDGE")
		handle_falling_edge()
	else:
		print("RISING EDGE")
		handle_rising_edge()
	
	global elapse,distance,start,pulse,speed,rpm,multiplier
	elapse = time.time() - start  
	multiplier = 3600/elapse
	rpm = 1/elapse*60
	speed = (wheel_c*multiplier)/(1000)
	

try:
	print('Inializing speedometer')
	time.sleep(1)
	  
	GPIO.add_event_detect(hall,GPIO.BOTH,callback = get_pulse,bouncetime=20)
	  
	while True:
		if GPIO.input(channel):
    			print('Input was HIGH')
		else:
    			print('Input was LOW')
		print('rpm{0:.2f} speed{1:.2f} distance{2} elapse{3:.4f} multiplier{4:.2f}'.format(rpm,speed,distance,elapse,multiplier))
		time.sleep(0.1)
      		if speed < 1:
        		def get_distance():
				return distance
        		print(distance,'Meters')
        		break
        
except KeyboardInterrupt:
	print('End of program')
	GPIO.cleanup()
